apiVersion: v1
kind: ConfigMap
metadata:
  name: helm-values-templates
  namespace: argo
data:
  # The "tokens" -> ${} is going to be replaced in terraform by the template file function.

  # The values file for prometheus
  tooling-kibana-values-template.yaml: |
    #words

  # The values file for Jaeger
  tooling-jaeger-values-template.yaml: |
    provisionDataStore:
      cassandra: false
      elasticsearch: true
      kafka: false
    ingress:
      enabled: true
      path: /jaeger
      hosts:
        - ${fqdn}
    expose:
      ingress:
        hosts:
          core: ${fqdn}
  #  externalURL: "https://${fqdn}"
  #  annotations:
  #    cert-manager.io/cluster-issuer: letsencrypt
  #    ingress.kubernetes.io/ssl-redirect: "true"
  #    ingress.kubernetes.io/proxy-body-size: "0"
  #    nginx.ingress.kubernetes.io/ssl-redirect: "true"
  #    nginx.ingress.kubernetes.io/proxy-body-size: "0"
  #    kubernetes.io/ingress.class: nginx

  # The values file for Harbor
  tooling-harbor-values-template.yaml: |
    expose:
      ingress:
        hosts:
          core: ${fqdn}
    externalURL: "https://${fqdn}"
    annotations:
      cert-manager.io/cluster-issuer: letsencrypt
      ingress.kubernetes.io/ssl-redirect: "true"
      ingress.kubernetes.io/proxy-body-size: "0"
      nginx.ingress.kubernetes.io/ssl-redirect: "true"
      nginx.ingress.kubernetes.io/proxy-body-size: "0"
      kubernetes.io/ingress.class: nginx

  # The values file for ingress-nginx
  k8s-ingress-nginx-values-template.yaml: |
    controller:
      service:
        annotations: 
          service.beta.kubernetes.io/azure-dns-label-name: ${dns-name}
          service.beta.kubernetes.io/azure-load-balancer-resource-group: ${resource-group}
        loadBalancerIP: ${ip-addr}

  # The values file for argo cd
  tooling-argo-cd-values-template.yaml: |
    server:
      ingress:
        hosts:
          - ${fqdn}

        tls:
        - hosts:
          - ${fqdn}
          secretName: argocd-secret # do not change, this is provided by Argo CD

  # The values file for prometheus
  tooling-prometheus-values-template.yaml: |
    alertmanager:
      ## External URL which can access alertmanager
      baseURL: "https://${fqdn}/alertmanager"
      prefixURL: "/alertmanager"

      extraFlags:
      - web.route-prefix=/alertmanager

      ingress:
        hosts:
        - ${fqdn}

        tls:
        - secretName: alertmanager-tls
          hosts:
            - ${fqdn}

    server:
      ## External URL which can access alertmanager
      ## Maybe same with Ingress host name
      baseURL: "https://${fqdn}/prometheus"
      prefixURL: "/prometheus"

      extraFlags:
      - web.enable-lifecycle
      - web.route-prefix=/prometheus


      ingress:
        hosts:
        - ${fqdn}

        tls:
        - secretName: prometheus-tls
          hosts:
            - ${fqdn}

    ## Prometheus server ConfigMap entries
    ##
    serverFiles:

      bucket.yml:
        type: AZURE
        config:
          storage_account: "<account-name>"
          storage_account_key: "<account-key>"
          container: "thanos"
          endpoint: ""
          max_retries: 3

  # The values file for prometheus
  tooling-grafana-values-template.yaml: |
    ingress:
      path: /grafana
      hosts:
        - ${fqdn}

      extraPaths:
      - path: /grafana/(.*)
        backend:
          serviceName: grafana
          servicePort: 80

      tls:
      - hosts:
        - ${fqdn}
        secretName: grafana-tls

    grafana.ini:
      server:
        root_url: https://${fqdn}/grafana

  # The values file for prometheus
  tooling-thanos-values-template.yaml: |
    query:
      # Prefix for API and UI endpoints. This allows thanos UI to be served on a sub-path.
      # This option is analogous to --web.route-prefix of Promethus.
      webRoutePrefix: "/thanos-query"
      # Static prefix for all HTML links and redirect
      #  URLs in the UI query web interface. Actual
      #  endpoints are still served on / or the
      #  web.route-prefix. This allows thanos UI to be
      #  served behind a reverse proxy that strips a URL
      #  sub-path.
      webExternalPrefix: "/thanos-query"
      
      # The http endpoint to communicate with other components
      http:
        ingress:
          hosts:
          - ${fqdn}
          tls:
          - secretName: thanos-query-tls
            hosts:
              - ${fqdn}

    objstore:
      type: AZURE
      config:
        storage_account: "<account-name>"
        storage_account_key: "<account-key>"
        container: "thanos"
        endpoint: ""
        max_retries: 3

  # The values file for HA vault
  tooling-vault-values-template.yaml: |
    server:
      extraVolumes:
      - type: secret
        name: vault-storage-config
        path: null
        
      extraArgs: -config=/vault/userconfig/vault-storage-config/config.hcl

      ingress:
        enabled: true
        annotations: 
          kubernetes.io/ingress.class: nginx
          cert-manager.io/cluster-issuer: letsencrypt-prod
        hosts:
          - host: ${fqdn}
            paths:
              - /vault(/|$)(.*)

        tls: 
        - secretName: vault-tls
          hosts:
            - ${fqdn}

      standalone:
        enabled: "false"

      ha:
        enabled: true
        replicas: 3
    # Vault UI
    ui:
      enabled: true
      
  # The values file for HA postgresql
  tooling-postgresql-values-template.yaml: |
    persistence:
      enabled: true

      mountPath: /bitnami/postgresql/vault

    postgresql:
      initdbScripts:
        vault.sql: |
          CREATE DATABASE vault;
          \c vault;
          CREATE TABLE vault_kv_store (
            parent_path TEXT COLLATE "C" NOT NULL,
            path        TEXT COLLATE "C",
            key         TEXT COLLATE "C",
            value       BYTEA,
            CONSTRAINT pkey PRIMARY KEY (path, key)
          );
          CREATE INDEX parent_path_idx ON vault_kv_store (parent_path);
          CREATE TABLE vault_ha_locks (
            ha_key                                      TEXT COLLATE "C" NOT NULL,
            ha_identity                                 TEXT COLLATE "C" NOT NULL,
            ha_value                                    TEXT COLLATE "C",
            valid_until                                 TIMESTAMP WITH TIME ZONE NOT NULL,
            CONSTRAINT ha_key PRIMARY KEY (ha_key)
          );

  # The values file for argo
  tooling-argo-wf-values-template.yaml: |
    server:
      enabled: true
      # only updates base url of resources on client side,
      # it's expected that a proxy server rewrites the request URL and gets rid of this prefix
      # https://github.com/argoproj/argo/issues/716#issuecomment-433213190
      baseHref: /argo/

      # Run the argo server in "secure" mode. Configure this value instead of
      # "--secure" in extraArgs. See the following documentation for more details
      # on secure mode:
      # https://argoproj.github.io/argo/tls/#encrypted
      secure: true

      ## Ingress configuration.
      ## ref: https://kubernetes.io/docs/user-guide/ingress/
      ##
      ingress:
        enabled: true

        ## Annotations to be added to the web ingress.
        ##
        annotations:
          kubernetes.io/ingress.class: nginx
          nginx.ingress.kubernetes.io/rewrite-target: /$2
          cert-manager.io/cluster-issuer: letsencrypt-prod
          nginx.ingress.kubernetes.io/backend-protocol: HTTPS
          
        ## Hostnames.
        ## Must be provided if Ingress is enabled.
        ##
        hosts:
          - ${fqdn}

        ## Additional Paths for each host
        # backends:
        #   - serviceName: "ssl-redirect"
        #     servicePort: "use-annotation"
        
        paths:
          - path: /argo(/|$)(.*)

        ## TLS configuration.
        ## Secrets must be manually created in the namespace.
        ##
        tls:
          - secretName: argo-ui-tls
            hosts:
              - ${fqdn}
    minio:
      # If set to true then chart installs minio and generate according artifactRepository section in workflow controller config map
      install: true
      defaultBucket:
        enabled: true
        name: argo-artifacts
