apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: oauth-enable-single-app-wf-tp
  namespace: argo
spec:
  entrypoint: oauth-enable-single-app-wf
  podGC:
    strategy: OnWorkflowSuccess
  templates:
    - name: oauth-enable-single-app-wf 
      inputs:
        parameters:
          - name: repo
          - name: script
          - name: server-url
        artifacts:
          - name: kube-config
      steps:
      - - name: git-clone
          templateRef:
            name: git-clone-template
            template: git-clone
          arguments:
            parameters:
            - name: ssh-url
              value: '{{inputs.parameters.repo}}'

      - - name: oauth-enable
          template: oauth-enable
          arguments:
            parameters:
            - name: server-url
              value: '{{inputs.parameters.server-url}}'
            - name: script
              value: '{{inputs.parameters.script}}'
            artifacts:
            - name: repo
              from: '{{steps.git-clone.outputs.artifacts.repo}}'
            - name: kube-config
              from: '{{inputs.artifacts.kube-config}}'


    - name: oauth-enable
      metadata:
        annotations:
          vault.hashicorp.com/agent-inject: "true"
          vault.hashicorp.com/role: "k8s-secrets"
          vault.hashicorp.com/agent-inject-secret-oauth-creds: "k8s/data/oauth/creds"
          vault.hashicorp.com/agent-inject-template-oauth-creds: |
            {{ with secret "k8s/data/oauth/creds" -}}
              export oauth_argocd="{{ .Data.data.argocd }}"
              export oauth_argowf="{{ .Data.data.argowf }}"
              export oauth_grafana="{{ .Data.data.grafana }}"
              export oauth_jaeger="{{ .Data.data.jaeger }}"
              export oauth_tenant_id="{{ .Data.data.tenantid }}"
              export oauth_client_id="{{ .Data.data.clientid }}"
            {{- end }}
      inputs:
        parameters:
        - name: server-url
        - name: script
        artifacts:
        - name: repo
          path: /repo
        - name: kube-config
          path: /.kube/config
        - name: argocd
          path: /bin/argocd
          mode: 0755
          http:
            url: 'https://github.com/argoproj/argo-cd/releases/download/v1.8.1/argocd-linux-amd64'        
        - name: yq
          path: /bin/yq
          mode: 0755
          http:
            url: 'https://github.com/mikefarah/yq/releases/download/v4.4.1/yq_linux_amd64'
        - name: jq
          path: /bin/jq
          mode: 0755
          http:
            url: https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64
        - name: kubectl
          path: /bin/kubectl
          mode: 0755
          http:
            url: https://storage.googleapis.com/kubernetes-release/release/v1.19.0/bin/linux/amd64/kubectl
      container:
        image: "{{inputs.parameters.server-url}}/tooling-j2cli/tooling-j2cli"
        command: ["/bin/sh", "-c"]
        args: 
          - |
            for f in /vault/**/*; do source $f; done;
            export KUBECONFIG=/.kube/config;
            export password=$(kubectl get pods -n argocd -l app.kubernetes.io/name=argocd-server -o name | cut -d'/' -f 2);
            argocd login tooling-argocd-server.argocd.svc.cluster.local --insecure --username admin --password $password;
            
            #Script
            {{inputs.parameters.script}}
        env:
        - name: ARGOCD_OPTS
          value: '--grpc-web-root-path /argocd'  

# - pull ever git repo that needs to enable oauth
#   - argo wf
#   - argo cd
#   - grafana
#   - harbor
#   - jaeger?

# make a j2 template (in the .setup) that contains the needed segments that's required for oauth

# run everything in parallel

# use argocd set --values-literal-file to update the existing value set.

# figure out a way to add the secrets to this list, without showing the value in helm.
# best practice is to deploy secrets outside of helm.